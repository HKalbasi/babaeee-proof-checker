const hesabiContext = `
Require Import Reals.
Require Import Lra.

Open Scope R.

Ltac normalize := intuition; try match goal with
  | [ |- (_ >= _)%R ] => apply Rle_ge
end.

Ltac kalbas_auto := try field; try lra; eauto.

Ltac replace_goal g := assert (g); kalbas_auto; normalize.

`;

const emptyContext = `
Ltac normalize := intros.

Ltac kalbas_auto := normalize.

`;

const arithContext = `
Require Import Arith.
Require Import Omega.
Ltac normalize := intros.

Ltac kalbas_auto := try omega; auto; normalize.
`;

const p3Context = `
${arithContext}
Lemma pow_lt_mono_2: forall a b : nat, a < b -> 2 ^ a < 2 ^ b.
Proof.
  intros.
  apply Nat.pow_lt_mono_r; auto.
Qed.
`;

const p5Context = `
${p3Context}
Lemma helper_1: forall a b: nat, a < b -> S (a) < 2 * b.
Proof.
  intros.
  omega.
Qed.

Lemma x_lt_pow_2 : forall x : nat , x < 2 ^ x.
Proof.
  intros.
  induction x.
  auto.
  assert (2 ^ S x = 2 * 2 ^ x).
  auto.
  rewrite H.
  apply helper_1.
  auto.
Qed.
`

const fiboContext = `
Require Import Omega.
Require Import Ring.

Ltac normalize := intuition.

Ltac kalbas_auto := try ring; try omega; eauto.

Ltac replace_goal g := assert (g); kalbas_auto; normalize.


Fixpoint fibo (n: nat) :=
  match n with
  | 0 => 1
  | (S x) => match x with
             | 0 => 1
             | S y => fibo x + fibo y
              end
  end.

Lemma fibo_def: forall n: nat, fibo (n + 2) = fibo (n + 1) + fibo n.
Proof.
  normalize.
  replace_goal (n + 2 = S (S n)).
  rewrite H.
  replace_goal (n + 1 = (S n)).
  rewrite H0.
  auto.
Qed.

Fixpoint fibo_sum (n: nat) := match n with
| 0 => 0
| S n => fibo_sum n + fibo n
end.

`;

const s = [
`
سلام. به اثبات چک کن خوش اومدی. توی این جا اثبات رو توی این محیط گرافیکی به ما
منتقل می کنی و ما بررسی می کنیم که درست باشه. توی چند مرحله که این مرحله اولشه
قراره یاد بگیری که چجوری می تونی اثبات رو به کامپیوتر بفهمونی.
توی صفحه ای که می بینی وضعیت اثبات نشون داده شده. چیزایی که بالای خط نوشته مفروضات
ما و چیزی که زیر خط نوشته چیزیه که باید ثابتش کنیم. الان ما دو تا قرض داریم. فرض
اول می گه که یه آدمی غرق شده و فرض دوم می گه که اگه آدمه غرق بشه میمیره. حالا
ما باید ثابت کنیم که اون آدمه مرده.


اول باید ببینیم که این جا داریم چی می بینیم؟ اون بالا که نوشته غرق شدن و مردن بعد
جلوش یه دو نقطه گذاشته و نوشته
Prop
منظور اینه که غرق شدن و مردن یه گزاره هستن. (پروپوزیشن به انگلیسی می شه گزاره و
Prop
مخفف پروپوزیشن هست) زیر اون، نوشته که اچ بعد دو نقطه بعد غرق شدن. اج فرض اول ماست
و دو نقطه ای که جلوش نوشته، نشون می ده که این اچ دقیقا داره صحت چه گزاره ای رو
برای ما مشخص می کنه. اچ صفر هم فرض دوم ماست و داره نشون می ده که
گزاره «غرق شدن نتیجه می دهد مردن» صحت داره. 


حالا حکم رو چجوری باید ثابت کنیم؟
برای این کار فرض دوم رو درگ کن (فعلا درگ دراپ پیاده نشده، روش کلیک کن) بعد روی حکم
دراپش کن. (یه کلیک دیگه) وقتی این کارو کنی به جای این که بخواد مردن یارو رو ثابت کنی، کافیه
که غرق شدن یارو رو ثابت کنی چون غرق شدنش مردنش رو نتیجه می ده. حالا که هدف تغییر کرده
به غرق شدن و غرق شدن تو مفروضاتمون هست، فرض رو
(اون دکمه ای که روش نوشته اچ)
درگ دراپ کن تو حکم تا اثبات کامل شه.
`,
`
همون قبلیه ولی یکم پیچیده تره. به جهت گزاره های شرطی توجه کن.
مثلا ما می دونیم که اگه یارو بمیره نفس هم نمی کشه ولی این تو اثبات این که یارو
مرده به ما کمک نمی کنه.

هم چنین علاوه بر این که می تونی فرض ها رو توی هدف اعمال کنی، می تونی توی هم دیگه
هم اعمالشون کنی. وقتی یه فرض رو توی یه فرض دیگه اعمال می کنی، یه فرض جدید به دست
میاری که حکم گزاره شرطی بوده. یعنی گزاره شرطی تو جهت مستقیم اجرا می شه ولی وقتی
یه فرض رو توی هدف اعمال می کنی، حکمی که می خوایم ثابت کنیم به فرض گزاره شرطی
تبدیل می شه و یعنی گزاره شرطی تو جهت برعکس اعمال می شه.

با این تفاسیر، هر طوری که دوست داری هدف رو ثابت کن.
`,
`
مسائل انتزاعی زیاد باحال نیستن. پس بیا یکم عدد قاطی بازی کنیم. توی این بخش باید
ثابت کنی که دو بتوان سه از دو بتوان صد کمتره. فرض اول اینه که می دونیم
سه از صد کمتره و فرض دوم می گه که اگه یه عدد طبیعی مثل آ از یه عدد مثل ب کمتر باشه، دو
به توانشون هم همین طوره. اثبات کاملا مثل قبله. فرض ها رو توی حکم درگ دراپ کن تا حکم
رو ثابت کنی.
`,
`
اینم همون مساله قبلیه. اون فرضی که توی سوال قبل داشتیم حقیقتا نمی شد بهش فرض گفت
و یه چیزیه که مستقل از شرایط درسته و ثابت می شه. به خاطر همین بردیمش توی پالت
قضیه ها (مثل پالت نقاشیه ولی به جای رنگ توش قضیه داره) اگه ماوس رو روش نگه داری
توضیح می ده که گزاره این قضیه دقیقا چیه. مثل مساله قبل حکم رو ثابت کن تا ادامه
بدیم.
`,
`
فرض دوم هم که می گفت سه از صد کوچیک تره واقعا فرض نیست. اون حتی قضیه هم نیست. یه
گزاره بدیهیه که از تعریف 3 و 100 و تعریف کوچکتر بودن نتیجه می شه. اگر چه می شه
این تعاریف رو باز کرد و به صورت دستی این رو نتیجه گرفت ولی ما نمی خوایم اذیتت کنیم
پس اگه دکمه اثبات خودکار که جدید اضافه شده رو بزنی خودمون چیزایی که بدیهیه رو
هندل می کنیم.
ممکنه واست سوال پیش بیاد که چه چیزایی رو اثبات خودکار می پذیره. جواب این سوال
اصلا آسون نیست. حتی ما سطح هوشمندی اثبات خودکار رو توی سوالای مختلف عوض می کنیم چون
بعضی از سوالا رو اثبات خودکار از بیخ ثابت می کنه.
وقتی که آموزش تموم شه، ما یه گزینه اضافه می کنیم که خودکار همه جا از اثبات خودکار
استفاده کنه. ولی چون اون ممکنه باعث شه که نفهمی داره چه اتفاقی میفته، الان
فعال نیست و باید دستی از اثبات خودکار استفاده کنی.
`,
`
یه چیز کوچولو دیگه هم یاد بگیریم بعد بریم چیز درست درمون ثابت کنیم. توی این سوال
می خوایم ثابت کنیم که ده از دو به توان صد کوچیک تره. این رو با قضیه ترایایی بودن
مقایسه توی اعداد طبیعی ثابت می کنیم. (اگه نمی دونی ترایایی چیه ماوس رو روی
قضیه ببر تا نشون بده که چیه) نرم افزاری که ما توی پشت این اثبات چک کن ازش استفاده
می کنیم (کوک) واقعا نرم افزار هوشمندیه و اگه برای این که بفهمید چقدر هوشمنده، می تونید
به این فکر کنید که چجوری خودتون می تونید اون رو پیاده سازی کنید. ولی با تمام این
هوشمندی، خیلی از چیز ها رو یا اشتباه می فهمه و یا نمی تونه بفهمه (و این به علت
عدم هوشمندیش نیست، بعضی وقت ها کلا نمی شه فهمید) مثلا این جا اگر شما بخواید از قضیه
ترایایی مقایسه استفاده کنید، اون نمی تونه بفهمه که شما چه ام ای رو در ذهنتون دارید
و اصلا هیچ کس نمی تونه بفهمه چون شما ممکنه توی ذهنتون دو بتوان پنج باشه یا دو بتوان
ده باشه یا اصلا 3 باشه! پس به صورت دستی بگید که چه ام ای مد نظرتون هست. توجه کنید که
اگر هوشمندی کوک نبود باید ان و پی رو هم خودتون دستی مشخص می کردید ولی کوک می فهمه که
برای اثبات هدف ان باید ده باشه و پی باید دو بتوان صد باشه.

اگر همین طوری تلاش کنید که
قضیه ترایایی رو روی هدف اعمال کنید بهتون ارور می ده که نمی دونم جای ام باید چی بزارم
ولی اگه شیفت رو نگه دارید و بعد درگ دراپ رو انجام بدید، ازتون می پرسه که با چه پارامتر
هایی؟ شما اون جا می تونید بنویسید:
m:=2^10
و بعد اثبات رو ادامه بدید.
`,
`
حالا نوبت یه چالش واقعیه. انتظار می ره که بفهمید سوال چیه و بتونید با دانشی که تا الان
دارید ثابتش کنید. راهنمایی وجود نداره و یه سری قضیه به درد نخور توی پالت قضیه ها هست
تا گمراهتون کنه 😈. فقط به یه نکته اشاره کنم و این که ما به دلایلی اعداد طبیعی رو که با
nat
نشون می دیم از صفر شروع می کنیم یعنی ۰ و ۱ و ۲ و ... اعداد طبیعی هستند. روی اثبات خودکار
حساب باز کنید و حواستون باشه که هدف رو به یه گزاره اثبات نشدنی تبدیل نکنید. موفق باشید!
`,
`
توی این قسمت با برابری و ابزار جدید بازنویسی آشنا می شیم. توی ریاضیات وقتی دو تا چیز
با هم برابر هستند یعنی می شه همه جا جایگزینشون کرد. ابزار بازنویسی هم دقیقا همین کار
رو انجام می ده. یعنی میاد سمت راست یک برابری رو توی حکم با سمت چپش جایگزین می کنه. برای
مثال بیاید خاصیت ترایایی بودن مساوی رو اثبات کنیم. اول ابزار باز نویسی رو انتخاب کنید
بعد فرض اول رو توی حکم درگ دراپ کنید. می بینید که آ با ب جایگزین می شه. حالا برای
ادامه یا می تونید از ابزار اپلای استفاده کنید و یا می تونید برابری دوم رو هم بازنویسی
کنید و بعد از قضیه ای که تو پالت هست استفاده کنید.
`,
`
بازنویسی فقط مخصوص مفروضات معلوم نیست. قضیه ها و حتی اونایی که پارامتر مجهول
دارن هم با بازنویسی کار می کنن. این جا هم کوک خودش سعی می کنه که پارامتر ها
رو تشخیص بده و اگه جایی کم آورد، می تونی مثل اعمال کردن، با نگه داشتن شیفت
پارامتر ها رو دستی معلوم کنی که البته تو این سوال لازم نمی شه.
`,
`
خیلی جاها به یه قضیه یا گزاره ای احتیاج پیدا می کنی که درسته و اعمال کردن یا
بازنویسی کردنش راحت مساله رو حل می کنه اما توی قضیه ها یا مفروضات نیست. با ابزار
ادعا می تونی اون رو ادعا کنی و ما اول ازت می خوایم که ادعات رو ثابت کنی و بعدش
ازت می خوایم که معلوم کنی به کمک این ادعا چجوری می شه حکم اصلی رو ثابت کرد. یعنی
اون ادعا رو توی فرض ها می بریم و بر می گردیم به حکم اصلی.

مثلا برای این سوال، ادعا کن که هشت همون دو بتوان سه عه، با اثبات خودکار ثابتش
کن و بعد حکم رو ثابت کن.
`,
`
یه مساله جدی ثابت کنیم و از روی برابری ها رد شیم.

به این نکته دقت کن که مثل اعمال کردن، فرض ها و قضیه ها رو می تونی توی هم دیگه هم
باز نویسی کنی.
هم چنین این جا جایگزینی رو برات باز می کنیم که یه جور ترکیب ادعا و بازنویسیه. انتخابش
کن و بعدش روی هدف کلیک کن، ازت می پرسه که چی رو می خوای با چی جایگزین کنی و بعدش
حکم رو با توجه به اون تغییر می ده.
`,
`
حالا با ابزار خیلی مهم تجزیه آشنا می شیم. تجزیه هر چیزی رو می شکونه به ماهیتش. خیلی
دقیق نمی شه توضیحش داد وقتی که زیرساخت کوک رو ندونیم ولی مهم نیست. با چند تا مثال
کاربرد های اصلی این ابزار رو یاد می گیریم.

اولین کاربردش، شکوندن «و منطقی» رو ببینید. ما این جا یه فرض داریم که و منطقی دو تا
گزارست. اون رو با ابزار تجزیه بشکنید، می بینید که به دو تا فرض مجزا تبدیل می شه. حالا
حکم رو می تونید ثابت کنید.
`,
];

const noTool = {
  rewrite: 'disable',
  destruct: 'disable',
  replace: 'disable',
  revert: 'disable',
  remember: 'disable',
  auto: 'disable',
  assert: 'disable',
};

const justAuto = {
  ...noTool,
  auto: 'manual',
};

const andRewrite = {
  ...justAuto,
  rewrite: 'enable',
};

const andAssert = {
  ...andRewrite,
  assert: 'enable',
}

const andReplace = {
  ...andAssert,
  replace: 'enable',
};

const andDestruct = {
  ...andReplace,
  destruct: 'enable',
};

export const problems = [
  {
    context: emptyContext,
    statement: s[0],
    tools: noTool,
    goal: 'forall ghargh_shodan mordan: Prop, ghargh_shodan -> (ghargh_shodan -> mordan) -> mordan',
  },
  {
    context: emptyContext,
    statement: s[1],
    tools: noTool,
    goal: 'forall ghargh_shodan nafas_nakeshidan mordan: Prop, ghargh_shodan -> (ghargh_shodan -> nafas_nakeshidan) -> (mordan -> nafas_nakeshidan) -> (nafas_nakeshidan -> mordan) -> mordan',
  },
  {
    context: arithContext,
    statement: s[2],
    tools: noTool,
    goal: '(3 < 100) -> (forall a b: nat, a < b -> 2 ^ a < 2 ^ b) -> 2 ^ 3 < 2 ^ 100',
  },
  {
    context: p3Context,
    statement: s[3],
    tools: noTool,
    pallete: {
      'pow_lt_mono_2': 'مقایسه توان های دو',
    },
    goal: '(3 < 100) -> 2 ^ 3 < 2 ^ 100',
  },
  {
    context: p3Context,
    statement: s[4],
    pallete: {
      'pow_lt_mono_2': 'مقایسه توان های دو',
    },
    tools: justAuto,
    goal: '2 ^ 3 < 2 ^ 100',
  },
  {
    context: p5Context,
    statement: s[5],
    pallete: {
      'pow_lt_mono_2': 'مقایسه توان های دو',
      'Nat.lt_trans': 'ترایایی بودن مقایسه',
      'x_lt_pow_2': 'هر عدد طبیعی از توان دو اش کوچک تر است',
    },
    tools: justAuto,
    goal: '10 < 2 ^ 100',
  },
  {
    context: p5Context,
    statement: s[6],
    pallete: {
      'pow_lt_mono_2': 'مقایسه توان های دو',
      'Nat.lt_trans': 'ترایایی بودن مقایسه',
      'x_lt_pow_2': 'هر عدد طبیعی از توان دو اش کوچک تر است',
      'Nat.pow_lt_mono_l': 'مقایسه توان با نمای برابر',
      'Nat.pow_lt_mono_r': 'مقایسه توان با پایه برابر',
      'Nat.pow_gt_1': 'مقایسه توان با یک',
    },
    tools: justAuto,
    goal: '(forall a b c d: nat, 1 < a -> a < c -> b < d -> a ^ b < c ^ d)',
  },
  {
    context: emptyContext,
    statement: s[7],
    pallete: {
      'eq_refl': 'برابری هر چیز با خودش',
    },
    tools: { ...andRewrite, auto: 'disable' },
    goal: 'forall a b c: nat, a = b -> b = c -> a = c',
  },
  {
    context: arithContext,
    statement: s[8],
    pallete: {
      'Nat.pow_1_l': 'یک به توان هر چیزی یک است',
    },
    tools: andRewrite,
    goal: '1 ^ (2 * 7) + 2 = 3',
  },
  {
    context: arithContext,
    statement: s[9],
    pallete: {
      'Nat.pow_mul_r': 'برابری آ به توان بی در سی',
    },
    tools: andAssert,
    goal: 'forall a:nat , 8 ^ a = 2 ^ (3*a)',
  },
  {
    context: arithContext,
    statement: s[10],
    pallete: {
      'Nat.pow_mul_r': 'برابری آ به توان بی در سی',
      'Nat.pow_inj_r': 'یک به یک بودن توان با پایه ثابت',
      'Nat.pow_inj_l': 'یک به یک بودن توان با نمای ثابت',
    },
    tools: andReplace,
    goal: 'forall a : nat, 2 ^ (a + 3) = 256 -> a = 5',
  },
  {
    context: arithContext,
    statement: s[11],
    tools: andDestruct,
    goal: 'forall A B C : Prop, A /\\ (A -> B) /\\ (B -> C) -> C',
  },
  {
    context: hesabiContext,
    goal: 'forall x y: R, (((x + y) / 2) ^ 2 >= x*y)%R',
    pallete: {
      'pow2_ge_0': 'نا برابری توان دو',
      'Rtotal_order': 'ترتیب کامل در اعداد حقیقی',
    },
  },
  {
    context: fiboContext,
    goal: 'forall n: nat, fibo_sum n = fibo (n + 1) - 1',
    pallete: ['nat_ind', 'fibo_def'],  
  },
];
